//! Advent of Code 2024 – Day 21 (Parts 1 & 2) — Keypad Conundrum
//!
//! Numeric keypad (robot at the door; starts on `A`):
//!     7 8 9
//!     4 5 6
//!     1 2 3
//!       0 A
//!
//! Directional keypad (all controller layers; each starts on `A`):
//!       ^ A
//!     < v >
//!
//! Part 1:
//!   - You type on a directional keypad which controls a robot on a directional
//!     keypad which controls the numeric keypad. That is **2 directional layers**.
//!
//!   - For each door code, compute the fewest keypresses **you** must type;
//!     complexity = presses * numeric_value(code). Sum complexities.
//!
//! Part 2:
//!   - Now there are **25 directional layers** total.
//!
//! Approach
//! --------
//! Let `moves(PAD, from, to)` return all **shortest** move strings (not counting
//! the final press) to move the pointer from `from` to `to` on PAD, never
//! stepping onto the gap. We generate up to two candidates: horizontal-then-
//! vertical and vertical-then-horizontal, discarding any that would step on the
//! gap. Then append `'A'` to press the target.
//!
//! Define `cost_dir(from, to, depth)` = minimum number of keys you must type on
//! a controller chain of length `depth` (directional keypads only) to press
//! `to` starting from pointer on `from` at the *next* layer down.
//!   - If `depth == 1`, you press the sequence yourself, so cost = length.
//!   - Else, that sequence must be generated by another directional keypad
//!     one layer up, so we expand each character recursively using `cost_dir`.
//!
//! Define `cost_num(from, to, depth)` similarly, but the lower layer is the
//! numeric keypad; we compute its minimal move strings, then ask the
//! directional chain of `depth` layers to produce those strings.
//!
//! For a whole code like "029A", sum `cost_num(prev, ch, depth)` over its chars
//! with `prev` starting at `'A'` on the numeric keypad.
//!
//! All transition costs are heavily memoized.

//!
//! Godwin's note to future self: 
//! AoC Day 21 is tricky because there are multiple shortest sequences for movements
//! between keypad keys, beyond just horizontal/vertical moves. The real challenge
//! is determining the "cost_dir" recursion depth, which needs to account for how many
//! layers of directional keypads are in the chain. 

use std::collections::{HashMap, HashSet};
use crate::utils;
use anyhow::Result;

#[derive(Clone)]
struct Keypad {
    pos: HashMap<char, (i32, i32)>,     // key -> (x,y)
    valid: HashSet<(i32, i32)>,         // valid cells (gap excluded)
}

impl Keypad {
    fn from_layout(lines: &[&str]) -> Self {
        let mut pos = HashMap::new();
        let mut valid = HashSet::new();
        for (y, row) in lines.iter().enumerate() {
            for (x, ch) in row.chars().enumerate() {
                if ch != ' ' {
                    pos.insert(ch, (x as i32, y as i32));
                    valid.insert((x as i32, y as i32));
                }
            }
        }
        Keypad { pos, valid }
    }

    #[inline]
    fn get(&self, ch: char) -> (i32, i32) {
        *self.pos.get(&ch).expect("key not on keypad")
    }

    #[inline]
    fn ok(&self, x: i32, y: i32) -> bool {
        self.valid.contains(&(x, y))
    }
}

fn path_ok(
    kp: &Keypad,
    sx: i32,
    sy: i32,
    dx: i32,
    dy: i32,
    horiz_first: bool,
) -> Option<String> {
    let mut x = sx;
    let mut y = sy;
    let mut s = String::new();

    let step_x = if dx > 0 { '>' } else { '<' };
    let step_y = if dy > 0 { 'v' } else { '^' };

    if horiz_first {
        // Horizontal moves first
        for _ in 0..dx.abs() {
            x += if dx > 0 { 1 } else { -1 };
            if !kp.ok(x, y) { return None; }
            s.push(step_x);
        }
        // Then vertical
        for _ in 0..dy.abs() {
            y += if dy > 0 { 1 } else { -1 };
            if !kp.ok(x, y) { return None; }
            s.push(step_y);
        }
    } else {
        // Vertical moves first
        for _ in 0..dy.abs() {
            y += if dy > 0 { 1 } else { -1 };
            if !kp.ok(x, y) { return None; }
            s.push(step_y);
        }
        // Then horizontal
        for _ in 0..dx.abs() {
            x += if dx > 0 { 1 } else { -1 };
            if !kp.ok(x, y) { return None; }
            s.push(step_x);
        }
    }

    Some(s)
}

fn move_candidates(kp: &Keypad, from: char, to: char) -> Vec<String> {
    let (sx, sy) = kp.get(from);
    let (tx, ty) = kp.get(to);
    let dx = tx - sx;
    let dy = ty - sy;

    let mut cand = Vec::new();
    if let Some(mut s) = path_ok(kp, sx, sy, dx, dy, true) {
        s.push('A');
        cand.push(s);
    }
    if let Some(mut s) = path_ok(kp, sx, sy, dx, dy, false) {
        s.push('A');
        cand.push(s);
    }
    cand.sort();
    cand.dedup();
    cand
}

#[derive(Default)]
struct Memos {
    dir: HashMap<(char, char, usize), u64>, // (from,to,depth)
    num: HashMap<(char, char, usize), u64>, // (from,to,depth)
}

fn cost_dir(
    from: char,
    to: char,
    depth: usize,
    dir_pad: &Keypad,
    mem: &mut Memos,
) -> u64 {
    if depth == 0 {
        return 0;
    }
    if depth == 1 {
        return move_candidates(dir_pad, from, to)
            .into_iter()
            .map(|s| s.len() as u64)
            .min()
            .unwrap();
    }
    if let Some(&v) = mem.dir.get(&(from, to, depth)) {
        return v;
    }

    let mut best = u64::MAX;
    for seq in move_candidates(dir_pad, from, to) {
        let mut prev = 'A';
        let mut total = 0u64;
        for ch in seq.chars() {
            total += cost_dir(prev, ch, depth - 1, dir_pad, mem);
            prev = ch;
        }
        best = best.min(total);
    }
    mem.dir.insert((from, to, depth), best);
    best
}

fn cost_num(
    from: char,
    to: char,
    dir_depth: usize,
    num_pad: &Keypad,
    dir_pad: &Keypad,
    mem: &mut Memos,
) -> u64 {
    if let Some(&v) = mem.num.get(&(from, to, dir_depth)) {
        return v;
    }
    let mut best = u64::MAX;
    for seq in move_candidates(num_pad, from, to) {
        let mut prev = 'A';
        let mut total = 0u64;
        for ch in seq.chars() {
            total += cost_dir(prev, ch, dir_depth, dir_pad, mem);
            prev = ch;
        }
        best = best.min(total);
    }
    mem.num.insert((from, to, dir_depth), best);
    best
}

fn code_cost(code: &str, dir_depth: usize, num_pad: &Keypad, dir_pad: &Keypad, mem: &mut Memos) -> u64 {
    let mut prev = 'A';
    let mut total = 0u64;
    for ch in code.chars() {
        total += cost_num(prev, ch, dir_depth, num_pad, dir_pad, mem);
        prev = ch;
    }
    total
}

fn read_codes(input: &str) -> Vec<String> {
    input
        .lines()
        .map(|s| s.trim())
        .filter(|s| !s.is_empty())
        .map(|s| s.to_string())
        .collect()
}

fn numeric_value(code: &str) -> u64 {
    let trimmed = code.trim_end_matches('A');
    trimmed.parse::<u64>().unwrap()
}

fn part1_sum_complexity(input: &str) -> u64 {
    let codes = read_codes(input);

    let num_pad = Keypad::from_layout(&[
        "789",
        "456",
        "123",
        " 0A",
    ]);
    let dir_pad = Keypad::from_layout(&[
        " ^A",
        "<v>",
    ]);

    // Part 1: 2 directional layers total.
    let depth = 2;

    let mut mem = Memos::default();
    codes
        .iter()
        .map(|code| code_cost(code, depth, &num_pad, &dir_pad, &mut mem) * numeric_value(code))
        .sum()
}

fn part2_sum_complexity(input: &str) -> u64 {
    let codes = read_codes(input);

    let num_pad = Keypad::from_layout(&[
        "789",
        "456",
        "123",
        " 0A",
    ]);
    let dir_pad = Keypad::from_layout(&[
        " ^A",
        "<v>",
    ]);

    // Part 2: 25 directional layers total.
    let depth = 25;

    let mut mem = Memos::default();
    codes
        .iter()
        .map(|code| code_cost(code, depth, &num_pad, &dir_pad, &mut mem) * numeric_value(code))
        .sum()
}

pub fn solve() -> Result<()> {
    let input = utils::load_input(2024, 21)?;

    let p1 = part1_sum_complexity(&input);
    println!("Part 1: {}", p1);

    let p2 = part2_sum_complexity(&input);
    println!("Part 2: {}", p2);

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    const EX: &str = r#"
029A
980A
179A
456A
379A
"#;

    #[test]
    fn example_part1_total_complexity() {
        // Sum published in the problem statement for Part 1.
        assert_eq!(part1_sum_complexity(EX), 126_384);
    }

    #[test]
    fn single_code_lengths_match_examples() {
        let num_pad = Keypad::from_layout(&["789","456","123"," 0A"]);
        let dir_pad = Keypad::from_layout(&[" ^A","<v>"]);
        let mut mem = Memos::default();

        // With depth=2 (Part 1), 029A requires 68 presses.
        let presses_029a = code_cost("029A", 2, &num_pad, &dir_pad, &mut mem);
        assert_eq!(presses_029a, 68);
    }
}
